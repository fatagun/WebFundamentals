<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Web fundementals</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section>
					<h3>HTTP Overview</h3>

				</section>

				<section>
					<section>
						<h3>Brief history of HTTP</h3>
						<div>Initial specs of HTTP was very simple. </div>

						<img src="images/originalhttp.png" />
					</section>

					<section>
						<div>
							HTTP/0.9 was release in 1991 by Tim Barnes Lee. <br />
							It was a text based request, response protocol. <br />
							Only HTML was supported. <br />
							After each request; connection was terminated. <br />
						</div>
					</section>

					<section>
						<p>
							Later on, HTTP/0.9 was extended to HTTP/1.0, request and response headers were added, also, you request images, text files, CSS and other. Every connection required a 3 way handshake which was very wasteful. 
						</p>
					</section>
					<section>
						<p>
							In 1999, HTTP/1.1 was released.<br /> Persistent connections (keep alive) was introduced, chunked transfer encoding and host header were added. With host headers, it was possible to host multiple sites for an IP. It was a breakthrough. <br />
							Connection header was introduced (Connection : keep-alive), which eliminated 3 way handshake for every request. Single TCP connection was sufficient for communication. 
						</p>
					</section>

					<section>
						<p>
							It was 2015 when HTTP/2 was release with several enhancements to prior versions, mostly targeting performance and common HTTP/1.1 problems.  
						</p>
					</section>
				</section>

				<section>
					<h3>HTTP Basics</h3>
				</section>

				<section>
					<h3>Request/Response Model</h3>
				</section>

				<section>
					<h3>URLs</h3>
				</section>

				<section>
					<h3>Verbs</h3>
				</section>

				<section>
					<section>
						<h3>HTTP Status Codes</h3>
						<ul>
							<li>1xx : Informational</li>
							<li>2xx : Successful</li>
							<li>3xx : Redirect</li>
							<li>4xx : Client Error</li>
							<li>5xx : Server Error</li>
						</ul>
					</section>
					<section>
						<h4>1xx</h4>
						<div>
							<ul>
								<li>100 : Continue</li>
							</ul>
						</div>
					</section>
					<section>
						<h4>2xx</h4>
						<div>
							<ul>
								<li>200 : OK</li>
								<li>201 : Created</li>
								<li>202 : Accepted</li>
							</ul>
						</div>
					</section>
					<section>
						<h4>3xx</h4>
						<div>
							<ul>
								<li>301 : Moved Permanently</li>
								<li>304 : Not Modified</li>
								<li>307 : Temporary Redirect</li>
							</ul>
						</div>
					</section>
					<section>
						<h4>4xx</h4>

						<div>
							<ul>
								<li>400 : Bad Request</li>
								<li>401 : Unauthorised</li>
								<li>403 : Forbidden</li>
								<li>404 : Not found</li>
								<li>405 : Method not allowed</li>
							</ul>
						</div>
					</section>
					<section>
						<h4>5xx</h4>

						<div>
							<ul>
								<li>500 : Internal server error</li>
								<li>501 : Not implemented</li>
								<li>502 : Bad Gateway</li>
								<li>503 : Service unavailable</li>
								<li>504 : Gateway timeout</li>
							</ul>
						</div>
					</section>

					<section>
						More at: <a href="https://httpstatuses.com/" target="firat">Http statuses</a>
					</section>
				</section>

				<section>
					<h3>Headers</h3>
				</section>

				<section>
					<h3>Request format</h3>
				</section>

				<section>
					<h3>Response format</h3>
				</section>

				<section>
					<h3>HTTP Connections</h3>
				</section>

				<section>
					<section>SSL Handshake</section>
					<section>
						
					</section>
				</section>

				<section>
					<section>HTTP Performance Optimization</section>
					<section>
						<ul>
							<li></li>
						</ul>
					</section>
				</section>

				<section>
					<section>
						<h3>Problems with HTTP/1.1</h3>

						<div>
							<ul>
							 	<li>It wasn’t designed for todays web pages, ie: 100+ HTTP requests, and 2MB+ page size.</li>
							 	<li>Requires multiple connections</li>
							 	<li>Lack of prioritization</li>
							 	<li>Verbose headers</li>
							 	<li>Head of line blocking</li>
							</ul>
						</div>
					</section>

					<section>
						<strong>Multiple Connections</strong>

						<p>
							When the app requires 50+ HTTP requests, there is a limit to the number of connections a browser can open per host, most browsers support 6 connections simultaneously.
						</p>
						<p>
							Establishing a connection requires 3 way handshake.
						</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Common Failures Reasons</h3>
					</section>
					<section>
						<strong>#1: Big systems fail more often than small systems.</strong>
						<p>Big systems have more external and internal dependencies along with many moving parts. Therefore, big systems should have many defensive mechanisms in place.</p>
					</section>
					<section>
						<strong>#2: Blocked threads are the number one cause of most failures.</strong>
						<p>Slow applications and hung threads are the most popular reasons of failures. These reasons lead to cascading failures and chain reactions. Blocked/hung threads can happen due to several reasons like deadlocks, starvation and live locks. Hung thread detection policies, timeouts, circuit breakers and bulkheads can prevent these failures.</p>
					</section>
					<section>
						<strong>#3: Integration points are number one killer in any system.</strong>
						<p>Every integration point eventually fails, however a failure in the integration point shouldn’t take down the whole application. Cascading failures occur when problems in one integration point propagates. Failures in integrated services becomes your problem. It even become more serious if you are not prepared for it.</p>
					</section>
					<section>
						<strong>#4: Tight coupled systems fail more often than loose coupled systems.</strong>
						<p>Decoupling middleware is a good practice to enable loose coupling for integration. This principle is applicable and best practice for cloud native applications.</p>
					</section>
					<section>
						<strong>#5: High traffic site's Resource/Connections pools get drained very quickly.</strong>
						<p>Resource/Connection pool have limitations. They can run out of resources rapidly and application performance will start degrading.</p>
					</section>
					<section>
						<strong>#6: Unbalanced capacities causes failures and scalability problems for applications.</strong>
						<p>If the capacities are not aligned, then you have a problem. Capacity and sizing should be planned accordingly.</p>
					</section>
					<section>
						<strong>#7: Never trust a system you have no control over.</strong>
						<p>The downstream application which is running a blocking code, can take your application down.</p>
					</section>
					<section>
						<strong>#8: Slow applications gets more traffic.</strong>
						<p>When an application is slow, users hit re-load button or F5 many times to reach to the application which causes more traffic.</p>
					</section>
					<section>
						<strong>#9: Fail fast all the time and retry gradually.</strong>
						<p>Exponential back off, Circuit breakers and timeouts should be embraced. User friendly error codes or default messages should be presented to the user until the stability is established.</p>
					</section>
					<section>
						<strong>#10: Appreciate your hardware resources and utilize them wisely.</strong>
						<p>Don't fall for CPU and Memory is CHEAP. This is not TRUE. Long running CPU cycles can cause contention which slows down your application and eventually it will fail. Paged or unfragmented memory causes slow seek times.</p>
					</section>
				</section>

				<section>
					<section>
						<h3>Characteristics of Scalable Systems</h3>
					</section>
					<section>
						<ul>
							<li>Increase the resources should proportionally increase the throughput.</li>
							<li></li>
						</ul>
					</section>
				</section>
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info about config & dependencies:
			// - https://github.com/hakimel/reveal.js#configuration
			// - https://github.com/hakimel/reveal.js#dependencies
			Reveal.initialize({
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
